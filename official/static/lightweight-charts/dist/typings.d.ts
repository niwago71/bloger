// Generated by dts-bundle-generator v5.9.0

/**
 * Represents a type of color.
 */
export declare enum ColorType {
	/** Solid color */
	Solid = "solid",
	/** Vertical gradient color */
	VerticalGradient = "gradient"
}
/**
 * Represents the crosshair mode.
 */
export declare enum CrosshairMode {
	/**
	 * Crosshair's horizontal line is anchored to the closest data point's close price.
	 */
	Normal = 0,
	/**
	 * Crosshair moves freely on the chart.
	 */
	Magnet = 1
}
/**
 * Represents the type of the last price animation for series such as area or line.
 */
export declare enum LastPriceAnimationMode {
	/**
	 * Animation is always disabled
	 */
	Disabled = 0,
	/**
	 * Animation is always enabled.
	 */
	Continuous = 1,
	/**
	 * Animation is active after new data.
	 */
	OnDataUpdate = 2
}
/**
 * Represents the possible line styles.
 */
export declare enum LineStyle {
	/**
	 * A solid line.
	 */
	Solid = 0,
	/**
	 * A dotted line.
	 */
	Dotted = 1,
	/**
	 * A dashed line.
	 */
	Dashed = 2,
	/**
	 * A dashed line with bigger dashes.
	 */
	LargeDashed = 3,
	/**
	 * A dottled line with more space between dots.
	 */
	SparseDotted = 4
}
/**
 * Represents the possible line types.
 */
export declare enum LineType {
	/**
	 * A line.
	 */
	Simple = 0,
	/**
	 * A stepped line.
	 */
	WithSteps = 1
}
/**
 * Represents the source of data to be used for the horizontal price line.
 */
export declare enum PriceLineSource {
	/**
	 * Use the last bar data.
	 */
	LastBar = 0,
	/**
	 * Use the last visible data of the chart viewport.
	 */
	LastVisible = 1
}
/**
 * Represents the price scale mode.
 */
export declare enum PriceScaleMode {
	/**
	 * Price scale shows prices. Price range changes linearly.
	 */
	Normal = 0,
	/**
	 * Price scale shows prices. Price range changes logarithmically.
	 */
	Logarithmic = 1,
	/**
	 * Price scale shows percentage values according the first visible value of the price scale.
	 * The first visible value is 0% in this mode.
	 */
	Percentage = 2,
	/**
	 * The same as percentage mode, but the first value is moved to 100.
	 */
	IndexedTo100 = 3
}
/**
 * Represents the type of a tick mark on the time axis.
 */
export declare enum TickMarkType {
	/**
	 * The start of the year (e.g. it's the first tick mark in a year).
	 */
	Year = 0,
	/**
	 * The start of the month (e.g. it's the first tick mark in a month).
	 */
	Month = 1,
	/**
	 * A day of the month.
	 */
	DayOfMonth = 2,
	/**
	 * A time without seconds.
	 */
	Time = 3,
	/**
	 * A time with seconds.
	 */
	TimeWithSeconds = 4
}
/**
 * This function is the main entry point of the Lightweight Charting Library.
 *
 * @param container - id of HTML element or element itself
 * @param options - any subset of ChartOptions to be applied at start.
 * @returns An interface to the created chart
 */
export declare function createChart(container: string | HTMLElement, options?: DeepPartial<ChartOptions>): IChartApi;
/**
 * Check if a time value is a business day object.
 *
 * @param time The time to check.
 * @returns `true` if `time` is a {@link BusinessDay} object, false otherwise.
 */
export declare function isBusinessDay(time: Time): time is BusinessDay;
/**
 * Check if a time value is a UTC timestamp number.
 *
 * @param time The time to check.
 * @returns `true` if `time` is a {@link UTCTimestamp} number, false otherwise.
 */
export declare function isUTCTimestamp(time: Time): time is UTCTimestamp;
/**
 * Returns the current version as a string. For example `'3.3.0'`.
 *
 * @returns {string} The version string.
 */
export declare function version(): string;
/**
 * Represents area series options.
 */
export declare type AreaSeriesOptions = SeriesOptions<AreaStyleOptions>;
/**
 * Represents area series options where all properties are optional.
 */
export declare type AreaSeriesPartialOptions = SeriesPartialOptions<AreaStyleOptions>;
/**
 * A custom function used to get autoscale information.
 */
export declare type AutoscaleInfoProvider = (baseImplementation: () => AutoscaleInfo | null) => AutoscaleInfo | null;
/**
 * Represents the background color of the chart.
 */
export declare type Background = SolidColor | VerticalGradientColor;
/**
 * Represents a price as a `number`.
 */
export declare type BarPrice = Nominal<number, "BarPrice">;
/**
 * Represents bar series options.
 */
export declare type BarSeriesOptions = SeriesOptions<BarStyleOptions>;
/**
 * Represents bar series options where all properties are options.
 */
export declare type BarSeriesPartialOptions = SeriesPartialOptions<BarStyleOptions>;
/**
 * Represents a range of bars and the number of bars outside the range.
 */
export declare type BarsInfo = Partial<Range<Time>> & {
	/**
	 * The number of bars before the start of the range.
	 */
	barsBefore: number;
	/**
	 * The number of bars after the end of the range.
	 */
	barsAfter: number;
};
/**
 * Represents a type of a base value of baseline series type.
 */
export declare type BaseValueType = BaseValuePrice;
/**
 * Structure describing baseline series options.
 */
export declare type BaselineSeriesOptions = SeriesOptions<BaselineStyleOptions>;
/**
 * Represents baseline series options where all properties are options.
 */
export declare type BaselineSeriesPartialOptions = SeriesPartialOptions<BaselineStyleOptions>;
/**
 * Represents candlestick series options.
 */
export declare type CandlestickSeriesOptions = SeriesOptions<CandlestickStyleOptions>;
/**
 * Represents candlestick series options where all properties are optional.
 */
export declare type CandlestickSeriesPartialOptions = SeriesPartialOptions<CandlestickStyleOptions>;
/**
 * Represents a coordiate as a `number`.
 */
export declare type Coordinate = Nominal<number, "Coordinate">;
/**
 * Represents a type `T` where every property is optional.
 */
export declare type DeepPartial<T> = {
	[P in keyof T]?: T[P] extends (infer U)[] ? DeepPartial<U>[] : T[P] extends readonly (infer X)[] ? readonly DeepPartial<X>[] : DeepPartial<T[P]>;
};
/**
 * Represents histogram series options.
 */
export declare type HistogramSeriesOptions = SeriesOptions<HistogramStyleOptions>;
/**
 * Represents histogram series options where all properties are optional.
 */
export declare type HistogramSeriesPartialOptions = SeriesPartialOptions<HistogramStyleOptions>;
/**
 * Represents a horizontal alignment.
 */
export declare type HorzAlign = "left" | "center" | "right";
/**
 * Represents line series options.
 */
export declare type LineSeriesOptions = SeriesOptions<LineStyleOptions>;
/**
 * Represents line series options where all properties are optional.
 */
export declare type LineSeriesPartialOptions = SeriesPartialOptions<LineStyleOptions>;
/**
 * Represents the width of a line.
 */
export declare type LineWidth = 1 | 2 | 3 | 4;
/**
 * Represents the to or from `number` in a logical range.
 */
export declare type Logical = Nominal<number, "Logical">;
/**
 * A logical range is an object with 2 properties: `from` and `to`, which are numbers and represent logical indexes on the time scale.
 *
 * The starting point of the time scale's logical range is the first data item among all series.
 * Before that point all indexes are negative, starting from that point - positive.
 *
 * Indexes might have fractional parts, for instance 4.2, due to the time-scale being continuous rather than discrete.
 *
 * Integer part of the logical index means index of the fully visible bar.
 * Thus, if we have 5.2 as the last visible logical index (`to` field), that means that the last visible bar has index 5, but we also have partially visible (for 20%) 6th bar.
 * Half (e.g. 1.5, 3.5, 10.5) means exactly a middle of the bar.
 */
export declare type LogicalRange = Range<Logical>;
/**
 * A custom function used to handle changes to the time scale's logical range.
 */
export declare type LogicalRangeChangeEventHandler = (logicalRange: LogicalRange | null) => void;
/**
 * A custom function use to handle mouse events.
 */
export declare type MouseEventHandler = (param: MouseEventParams) => void;
/**
 * This is the generic type useful for declaring a nominal type,
 * which does not structurally matches with the base type and
 * the other types declared over the same base type
 *
 * Usage:
 *
 * @example
 * type Index = Nominal<number, 'Index'>;
 * // let i: Index = 42; // this fails to compile
 * let i: Index = 42 as Index; // OK
 * @example
 * type TagName = Nominal<string, 'TagName'>;
 */
export declare type Nominal<T, Name extends string> = T & {
	/** The 'name' or species of the nominal. */
	[Symbol.species]: Name;
};
/**
 * Represents overlay price scale options.
 */
export declare type OverlayPriceScaleOptions = Omit<PriceScaleOptions, "visible" | "autoScale">;
/**
 * Represents information used to format prices.
 */
export declare type PriceFormat = PriceFormatBuiltIn | PriceFormatCustom;
/**
 * A function used to format a {@link BarPrice} as a string.
 */
export declare type PriceFormatterFn = (priceValue: BarPrice) => string;
/**
 * Represents the position of a series marker relative to a bar.
 */
export declare type SeriesMarkerPosition = "aboveBar" | "belowBar" | "inBar";
/**
 * Represents the shape of a series marker.
 */
export declare type SeriesMarkerShape = "circle" | "square" | "arrowUp" | "arrowDown";
/**
 * Represents the intersection of a series type `T`'s options and common series options.
 *
 * @see {@link SeriesOptionsCommon} for common options.
 */
export declare type SeriesOptions<T> = T & SeriesOptionsCommon;
/**
 * Represents a {@link SeriesOptions} where every property is optional.
 */
export declare type SeriesPartialOptions<T> = DeepPartial<T & SeriesOptionsCommon>;
/**
 * Represents a type of series.
 *
 * @see {@link SeriesOptionsMap}
 */
export declare type SeriesType = keyof SeriesOptionsMap;
/**
 * A custom function used to handle changes to the time scale's size.
 */
export declare type SizeChangeEventHandler = (width: number, height: number) => void;
/**
 * The `TickMarkFormatter` is used to customize tick mark labels on the time scale.
 *
 * This function should return `time` as a string formatted according to `tickMarkType` type (year, month, etc) and `locale`.
 *
 * Note that the returned string should be the shortest possible value and should have no more than 8 characters.
 * Otherwise, the tick marks will overlap each other.
 *
 * ```js
 * const customFormatter = (time, tickMarkType, locale) => { ... }
 * ```
 */
export declare type TickMarkFormatter = (time: UTCTimestamp | BusinessDay, tickMarkType: TickMarkType, locale: string) => string;
/**
 * The Time type is used to represent the time of data items.
 *
 * Values can be a {@link UTCTimestamp}, a {@link BusinessDay}, or a business day string in ISO format.
 *
 * @example
 * ```js
 * const timestamp = 1529899200; // Literal timestamp representing 2018-06-25T04:00:00.000Z
 * const businessDay = { year: 2019, month: 6, day: 1 }; // June 1, 2019
 * const businessDayString = '2021-02-03'; // Business day string literal
 * ```
 */
export declare type Time = UTCTimestamp | BusinessDay | string;
/**
 * A custom function used to override formatting of a time to a string.
 */
export declare type TimeFormatterFn = (time: BusinessDay | UTCTimestamp) => string;
/**
 * Represents a {@link Time} range.
 */
export declare type TimeRange = Range<Time>;
/**
 * A custom function used to handle changes to the time scale's time range.
 */
export declare type TimeRangeChangeEventHandler = (timeRange: TimeRange | null) => void;
/**
 * Represents a time a a UNIX timestamp.
 *
 * If your chart displays an intraday interval you should use a UNIX Timestamp.
 *
 * Note that JavaScript Date APIs like `Date.now` return a number of milliseconds but UTCTimestamp expects a number of seconds.
 *
 * Note that to prevent errors, you should cast the numeric type of the time to `UTCTimestamp` type from the package (`value as UTCTimestamp`) in TypeScript code.
 *
 * @example
 * ```ts
 * const timestamp = 1529899200 as UTCTimestamp; // Literal timestamp representing 2018-06-25T04:00:00.000Z
 * const timestamp2 = (Date.now() / 1000) as UTCTimestamp;
 * ```
 */
export declare type UTCTimestamp = Nominal<number, "UTCTimestamp">;
/**
 * Represents a vertical alignment.
 */
export declare type VertAlign = "top" | "center" | "bottom";
/**
 * Represents a visible price scale's options.
 *
 * @see {@link PriceScaleOptions}
 */
export declare type VisiblePriceScaleOptions = PriceScaleOptions;
/**
 * Represents style options for an area series.
 */
export interface AreaStyleOptions {
	/**
	 * Color of the top part of the area.
	 */
	topColor: string;
	/**
	 * Color of the bottom part of the area.
	 */
	bottomColor: string;
	/**
	 * Line color.
	 */
	lineColor: string;
	/**
	 * Line style.
	 */
	lineStyle: LineStyle;
	/**
	 * Line width in pixels.
	 */
	lineWidth: LineWidth;
	/**
	 * Line type.
	 */
	lineType: LineType;
	/**
	 * Show the crosshair marker.
	 */
	crosshairMarkerVisible: boolean;
	/**
	 * Crosshair marker radius in pixels.
	 */
	crosshairMarkerRadius: number;
	/**
	 * Crosshair marker border color. An empty string falls back to the the color of the series under the crosshair.
	 */
	crosshairMarkerBorderColor: string;
	/**
	 * The crosshair marker background color. An empty string falls back to the the color of the series under the crosshair.
	 */
	crosshairMarkerBackgroundColor: string;
	/**
	 * Last price animation mode.
	 */
	lastPriceAnimation: LastPriceAnimationMode;
}
/**
 * Represents the margin used when updating a price scale.
 */
export interface AutoScaleMargins {
	/** The number of pixels for bottom margin */
	below: number;
	/** The number of pixels for top margin */
	above: number;
}
/**
 * Represents information used to update a price scale.
 */
export interface AutoscaleInfo {
	/**
	 * Price range.
	 */
	priceRange: PriceRange;
	/**
	 * Scale margins.
	 */
	margins?: AutoScaleMargins;
}
/**
 * Represents options for how the time and price axes react to mouse movements.
 */
export interface AxisPressedMouseMoveOptions {
	/**
	 * Enable scaling the time axis by holding down the left mouse button and moving the mouse.
	 */
	time: boolean;
	/**
	 * Enable scaling the price axis by holding down the left mouse button and moving the mouse.
	 */
	price: boolean;
}
/**
 * Represents a bar with a {@link Time} and open, high, low, and close prices.
 */
export interface BarData {
	/**
	 * The bar time.
	 */
	time: Time;
	/**
	 * The open price.
	 */
	open: number;
	/**
	 * The high price.
	 */
	high: number;
	/**
	 * The low price.
	 */
	low: number;
	/**
	 * The close price.
	 */
	close: number;
}
/**
 * Represents a bar's open, high, low, close (OHLC) prices.
 */
export interface BarPrices {
	/**
	 * The open price.
	 */
	open: BarPrice;
	/**
	 * The high price.
	 */
	high: BarPrice;
	/**
	 * The low price.
	 */
	low: BarPrice;
	/**
	 * The close price.
	 */
	close: BarPrice;
}
/**
 * Represents style options for a bar series.
 */
export interface BarStyleOptions {
	/**
	 * Color of rising bars.
	 */
	upColor: string;
	/**
	 * Color of falling bars.
	 */
	downColor: string;
	/**
	 * Show open lines on bars.
	 */
	openVisible: boolean;
	/**
	 * Show bars as sticks.
	 */
	thinBars: boolean;
}
/**
 * Represents a type of priced base value of baseline series type.
 */
export interface BaseValuePrice {
	/**
	 * Distinguished type value.
	 */
	type: "price";
	/**
	 * Price value.
	 */
	price: number;
}
/**
 * Represents style options for a baseline series.
 */
export interface BaselineStyleOptions {
	/**
	 * Base value of the series.
	 */
	baseValue: BaseValueType;
	/**
	 * The first color of the top area.
	 */
	topFillColor1: string;
	/**
	 * The second color of the top area.
	 */
	topFillColor2: string;
	/**
	 * The line color of the top area.
	 */
	topLineColor: string;
	/**
	 * The first color of the bottom area.
	 */
	bottomFillColor1: string;
	/**
	 * The second color of the bottom area.
	 */
	bottomFillColor2: string;
	/**
	 * The line color of the bottom area.
	 */
	bottomLineColor: string;
	/**
	 * Line width.
	 */
	lineWidth: LineWidth;
	/**
	 * Line style.
	 */
	lineStyle: LineStyle;
	/**
	 * Show the crosshair marker.
	 */
	crosshairMarkerVisible: boolean;
	/**
	 * Crosshair marker radius in pixels.
	 */
	crosshairMarkerRadius: number;
	/**
	 * Crosshair marker border color. An empty string falls back to the the color of the series under the crosshair.
	 */
	crosshairMarkerBorderColor: string;
	/**
	 * The crosshair marker background color. An empty string falls back to the the color of the series under the crosshair.
	 */
	crosshairMarkerBackgroundColor: string;
	/**
	 * Last price animation mode.
	 */
	lastPriceAnimation: LastPriceAnimationMode;
}
/**
 * Represents a time as a day/week/month.
 *
 * ```js
 * const day = { year: 2019, month: 6, day: 1 }; // June 1, 2019
 * ```
 */
export interface BusinessDay {
	/**
	 * The year.
	 */
	year: number;
	/**
	 * The month.
	 */
	month: number;
	/**
	 * The day.
	 */
	day: number;
}
/**
 * Represents style options for a candlestick series.
 */
export interface CandlestickStyleOptions {
	/**
	 * Color of rising candles.
	 */
	upColor: string;
	/**
	 * Color of falling candles.
	 */
	downColor: string;
	/**
	 * Enable high and low prices candle wicks.
	 */
	wickVisible: boolean;
	/**
	 * Enable candle borders.
	 */
	borderVisible: boolean;
	/**
	 * Border color.
	 */
	borderColor: string;
	/**
	 * Border color of rising candles.
	 */
	borderUpColor: string;
	/**
	 * Border color of falling candles.
	 */
	borderDownColor: string;
	/**
	 * Wick color.
	 */
	wickColor: string;
	/**
	 * Wick color of rising candles.
	 */
	wickUpColor: string;
	/**
	 * Wick color of falling candles.
	 */
	wickDownColor: string;
}
/**
 * Structure describing options of the chart. Series options are to be set separately
 */
export interface ChartOptions {
	/** Width of the chart in pixels. */
	width: number;
	/** Height of the chart in pixels. */
	height: number;
	/**
	 * Watermark options.
	 *
	 * A watermark is a background label that includes a brief description of the drawn data. Any text can be added to it.
	 *
	 * Please make sure you enable it and set an appropriate font color and size to make your watermark visible in the background of the chart.
	 * We recommend a semi-transparent color and a large font. Also note that watermark position can be aligned vertically and horizontally.
	 */
	watermark: WatermarkOptions;
	/** Layout options. */
	layout: LayoutOptions;
	/** Left price scale options. */
	leftPriceScale: VisiblePriceScaleOptions;
	/** Right price scale options. */
	rightPriceScale: VisiblePriceScaleOptions;
	/** Overlay price scale options. */
	overlayPriceScales: OverlayPriceScaleOptions;
	/** Time scale options. */
	timeScale: TimeScaleOptions;
	/** Crosshair options. */
	crosshair: CrosshairOptions;
	/** Grid options. */
	grid: GridOptions;
	/** Localization options. */
	localization: LocalizationOptions;
	/** Scroll options, or a boolean flag that enables/disables scrolling. */
	handleScroll: HandleScrollOptions | boolean;
	/** Scale options, or a boolean flag that enables/disables scaling. */
	handleScale: HandleScaleOptions | boolean;
	/** Kinetic scroll options. */
	kineticScroll: KineticScrollOptions;
}
/** Structure describing a crosshair line (vertical or horizontal) */
export interface CrosshairLineOptions {
	/**
	 * Crosshair line color.
	 */
	color: string;
	/**
	 * Crosshair line width.
	 */
	width: LineWidth;
	/**
	 * Crosshair line style.
	 */
	style: LineStyle;
	/**
	 * Display the corosshair line.
	 */
	visible: boolean;
	/**
	 * Display the crosshair label on the relevant scale.
	 */
	labelVisible: boolean;
	/**
	 * Crosshair label background color.
	 */
	labelBackgroundColor: string;
}
/** Structure describing crosshair options  */
export interface CrosshairOptions {
	/** Crosshair mode */
	mode: CrosshairMode;
	/** Vertical line options. */
	vertLine: CrosshairLineOptions;
	/** Horizontal line options. */
	horzLine: CrosshairLineOptions;
}
/** Grid line options. */
export interface GridLineOptions {
	/**
	 * Line color.
	 */
	color: string;
	/**
	 * Line style.
	 */
	style: LineStyle;
	/**
	 * Display the lines.
	 */
	visible: boolean;
}
/** Structure describing grid options. */
export interface GridOptions {
	/** Vertical grid line options. */
	vertLines: GridLineOptions;
	/** Horizontal grid line options. */
	horzLines: GridLineOptions;
}
/**
 * Represents options for how the chart is scaled by the mouse and touch gestures.
 */
export interface HandleScaleOptions {
	/**
	 * Enable scaling with the mouse wheel.
	 */
	mouseWheel: boolean;
	/**
	 * Enable scling with pinch/zoom gestures.
	 */
	pinch: boolean;
	/**
	 * Enable scaling the price and/or time scales by holding down the left mouse button and moving the mouse.
	 */
	axisPressedMouseMove: AxisPressedMouseMoveOptions | boolean;
	/**
	 * Enable resetting scaling by double-clicking the left mouse button.
	 */
	axisDoubleClickReset: boolean;
}
/**
 * Represents options for how the chart is scrolled by the mouse and touch gestures.
 */
export interface HandleScrollOptions {
	/**
	 * Enable scrolling with the mouse wheel.
	 */
	mouseWheel: boolean;
	/**
	 * Enable scrolling by holding down the left mouse button and moving the mouse.
	 */
	pressedMouseMove: boolean;
	/**
	 * Enable horizontal touch scrolling.
	 *
	 * When enabled the chart handles touch gestures that would normally scroll the webpage horizontally.
	 */
	horzTouchDrag: boolean;
	/**
	 * Enable vertical touch scrolling.
	 *
	 * When enabled the chart handles touch gestures that would normally scroll the webpage vertically.
	 */
	vertTouchDrag: boolean;
}
/**
 * Structure describing a single item of data for histogram series
 */
export interface HistogramData extends LineData {
	/**
	 * Optional color value for certain data item. If missed, color from HistogramSeriesOptions is used
	 */
	color?: string;
}
/**
 * Represents style options for a histogram series.
 */
export interface HistogramStyleOptions {
	/**
	 * Column color.
	 */
	color: string;
	/**
	 * Initial level of histogram columns.
	 */
	base: number;
}
/**
 * The main interface of a single chart.
 */
export interface IChartApi {
	/**
	 * Removes the chart object including all DOM elements. This is an irreversible operation, you cannot do anything with the chart after removing it.
	 */
	remove(): void;
	/**
	 * Sets fixed size of the chart. By default chart takes up 100% of its container.
	 *
	 * @param width - target width of the chart.
	 * @param height - target height of the chart.
	 * @param forceRepaint - true to initiate resize immediately. One could need this to get screenshot immediately after resize.
	 */
	resize(width: number, height: number, forceRepaint?: boolean): void;
	/**
	 * Creates an area series with specified parameters.
	 *
	 * @param areaOptions - customization parameters of the series being created.
	 * @returns an interface of the created series.
	 */
	addAreaSeries(areaOptions?: AreaSeriesPartialOptions): ISeriesApi<"Area">;
	/**
	 * Creates a baseline series with specified parameters.
	 *
	 * @param baselineOptions - customization parameters of the series being created.
	 * @returns an interface of the created series.
	 */
	addBaselineSeries(baselineOptions?: BaselineSeriesPartialOptions): ISeriesApi<"Baseline">;
	/**
	 * Creates a bar series with specified parameters.
	 *
	 * @param barOptions - customization parameters of the series being created.
	 * @returns an interface of the created series.
	 */
	addBarSeries(barOptions?: BarSeriesPartialOptions): ISeriesApi<"Bar">;
	/**
	 * Creates a candlestick series with specified parameters.
	 *
	 * @param candlestickOptions - customization parameters of the series being created.
	 * @returns an interface of the created series.
	 */
	addCandlestickSeries(candlestickOptions?: CandlestickSeriesPartialOptions): ISeriesApi<"Candlestick">;
	/**
	 * Creates a histogram series with specified parameters.
	 *
	 * @param histogramOptions - customization parameters of the series being created.
	 * @returns an interface of the created series.
	 */
	addHistogramSeries(histogramOptions?: HistogramSeriesPartialOptions): ISeriesApi<"Histogram">;
	/**
	 * Creates a line series with specified parameters.
	 *
	 * @param lineOptions - customization parameters of the series being created.
	 * @returns an interface of the created series.
	 */
	addLineSeries(lineOptions?: LineSeriesPartialOptions): ISeriesApi<"Line">;
	/**
	 * Removes a series of any type. This is an irreversible operation, you cannot do anything with the series after removing it
	 */
	removeSeries(seriesApi: ISeriesApi<SeriesType>): void;
	/**
	 * Subscribe to the chart click event.
	 *
	 * @param handler - handler to be called on mouse click.
	 * @example
	 * ```js
	 * function myClickHandler(param) {
	 *     if (!param.point) {
	 *         return;
	 *     }
	 *
	 *     console.log(`Click at ${param.point.x}, ${param.point.y}. The time is ${param.time}.`);
	 * }
	 *
	 * chart.subscribeClick(myClickHandler);
	 * ```
	 */
	subscribeClick(handler: MouseEventHandler): void;
	/**
	 * Unsubscribe a handler that was previously subscribed using {@link subscribeClick}.
	 *
	 * @param handler - previously subscribed handler
	 * @example
	 * ```js
	 * chart.unsubscribeClick(myClickHandler);
	 * ```
	 */
	unsubscribeClick(handler: MouseEventHandler): void;
	/**
	 * Subscribe to the crosshair move event.
	 *
	 * @param handler - handler to be called on crosshair move.
	 * @example
	 * ```js
	 * function myCrosshairMoveHandler(param) {
	 *     if (!param.point) {
	 *         return;
	 *     }
	 *
	 *     console.log(`Crosshair moved to ${param.point.x}, ${param.point.y}. The time is ${param.time}.`);
	 * }
	 *
	 * chart.subscribeClick(myCrosshairMoveHandler);
	 * ```
	 */
	subscribeCrosshairMove(handler: MouseEventHandler): void;
	/**
	 * Unsubscribe a handler that was previously subscribed using {@link subscribeCrosshairMove}.
	 *
	 * @param handler - previously subscribed handler
	 * @example
	 * ```js
	 * chart.unsubscribeCrosshairMove(myCrosshairMoveHandler);
	 * ```
	 */
	unsubscribeCrosshairMove(handler: MouseEventHandler): void;
	/**
	 * Returns API to manipulate a price scale.
	 *
	 * @param priceScaleId - id of the price scale.
	 * @returns Price scale API.
	 */
	priceScale(priceScaleId?: string): IPriceScaleApi;
	/**
	 * Returns API to manipulate the time scale
	 *
	 * @returns target API
	 */
	timeScale(): ITimeScaleApi;
	/**
	 * Applies new options to the chart
	 *
	 * @param options - any subset of chart options
	 */
	applyOptions(options: DeepPartial<ChartOptions>): void;
	/**
	 * Returns currently applied options
	 *
	 * @returns full set of currently applied options, including defaults
	 */
	options(): Readonly<ChartOptions>;
	/**
	 * Make a screenshot of the chart with all the elements excluding crosshair.
	 *
	 * @returns a canvas with the chart drawn on
	 */
	takeScreenshot(): HTMLCanvasElement;
}
/** Interface to be implemented by the object in order to be used as a price formatter */
export interface IPriceFormatter {
	/**
	 * Formatting function
	 *
	 * @param price - original price to be formatted
	 * @returns formatted price
	 */
	format(price: number): string;
}
/**
 * Represents the interface for interacting with price lines.
 */
export interface IPriceLine {
	/**
	 * Apply options to the price line.
	 *
	 * @param options The options to apply.
	 */
	applyOptions(options: Partial<PriceLineOptions>): void;
	/**
	 * Get the currently applied options.
	 */
	options(): Readonly<PriceLineOptions>;
}
/** Interface to control chart's price scale */
export interface IPriceScaleApi {
	/**
	 * Applies new options to the price scale
	 *
	 * @param options - any subset of PriceScaleOptions
	 */
	applyOptions(options: DeepPartial<PriceScaleOptions>): void;
	/**
	 * Returns currently applied options of the price scale
	 *
	 * @returns full set of currently applied options, including defaults
	 */
	options(): Readonly<PriceScaleOptions>;
	/**
	 * Returns a width of the price scale if it's visible or 0 if invisible.
	 */
	width(): number;
}
/**
 * Represents the interface for interacting with series.
 */
export interface ISeriesApi<TSeriesType extends SeriesType> {
	/**
	 * Returns current price formatter
	 *
	 * @returns interface to the price formatter object that can be used to format prices in the same way as the chart does
	 */
	priceFormatter(): IPriceFormatter;
	/**
	 * Converts specified series price to pixel coordinate according to the series price scale
	 *
	 * @param price - input price to be converted
	 * @returns pixel coordinate of the price level on the chart
	 */
	priceToCoordinate(price: number): Coordinate | null;
	/**
	 * Converts specified coordinate to price value according to the series price scale
	 *
	 * @param coordinate - input coordinate to be converted
	 * @returns price value of the coordinate on the chart
	 */
	coordinateToPrice(coordinate: number): BarPrice | null;
	/**
	 * Retrieves information about the series' data within a given logical range.
	 *
	 * @param range - the logical range to retrieve info for
	 * @returns the bars info for the given logical range: fields `from` and `to` are
	 * `Logical` values for the first and last bar within the range, and `barsBefore` and
	 * `barsAfter` count the the available bars outside the given index range. If these
	 * values are negative, it means that the given range us not fully filled with bars
	 * on the given side, but bars are missing instead (would show up as a margin if the
	 * the given index range falls into the viewport).
	 */
	barsInLogicalRange(range: Range<number>): BarsInfo | null;
	/**
	 * Applies new options to the existing series
	 *
	 * @param options - any subset of options
	 */
	applyOptions(options: SeriesPartialOptionsMap[TSeriesType]): void;
	/**
	 * Returns currently applied options
	 *
	 * @returns full set of currently applied options, including defaults
	 */
	options(): Readonly<SeriesOptionsMap[TSeriesType]>;
	/**
	 * Returns interface of the price scale the series is currently attached
	 *
	 * @returns IPriceScaleApi object to control the price scale
	 */
	priceScale(): IPriceScaleApi;
	/**
	 * Sets or replaces series data
	 *
	 * @param data - ordered (earlier time point goes first) array of data items. Old data is fully replaced with the new one.
	 */
	setData(data: SeriesDataItemTypeMap[TSeriesType][]): void;
	/**
	 * Adds or replaces a new bar
	 *
	 * @param bar - a single data item to be added. Time of the new item must be greater or equal to the latest existing time point.
	 * If the new item's time is equal to the last existing item's time, then the existing item is replaced with the new one.
	 */
	update(bar: SeriesDataItemTypeMap[TSeriesType]): void;
	/**
	 * Sets markers for the series
	 *
	 * @param data - array of series markers. This array should be sorted by time. Several markers with same time are allowed.
	 */
	setMarkers(data: SeriesMarker<Time>[]): void;
	/**
	 * Creates a new price line
	 *
	 * @param options - any subset of options
	 */
	createPriceLine(options: PriceLineOptions): IPriceLine;
	/**
	 * Removes an existing price line
	 *
	 * @param line - to remove
	 */
	removePriceLine(line: IPriceLine): void;
	/**
	 * Return the type of this series
	 *
	 * @returns this `SeriesType`
	 */
	seriesType(): TSeriesType;
}
/** Interface to chart time scale */
export interface ITimeScaleApi {
	/**
	 * Return the distance from the right edge of the time scale to the lastest bar of the series measured in bars.
	 *
	 * @returns {number} a distance from the right edge to the latest bar, measured in bars.
	 */
	scrollPosition(): number;
	/**
	 * Scrolls the chart to the specified position.
	 *
	 * @param position - target data position
	 * @param animated - setting this to true makes the chart scrolling smooth and adds animation
	 */
	scrollToPosition(position: number, animated: boolean): void;
	/**
	 * Restores default scroll position of the chart. This process is always animated.
	 */
	scrollToRealTime(): void;
	/**
	 * Returns current visible time range of the chart.
	 *
	 * @returns visible range or null if the chart has no data at all.
	 */
	getVisibleRange(): TimeRange | null;
	/**
	 * Sets visible range of data.
	 *
	 * @param range - target visible range of data.
	 * @example
	 * ```js
	 * chart.timeScale().setVisibleRange({
	 *     from: (new Date(Date.UTC(2018, 0, 1, 0, 0, 0, 0))).getTime() / 1000,
	 *     to: (new Date(Date.UTC(2018, 1, 1, 0, 0, 0, 0))).getTime() / 1000,
	 * });
	 * ```
	 */
	setVisibleRange(range: TimeRange): void;
	/**
	 * Returns the current visible [logical range](#logical-range) of the chart as an object with the first and last time points of the logical range, or returns `null` if the chart has no data.
	 *
	 * @returns visible range or null if the chart has no data at all.
	 */
	getVisibleLogicalRange(): LogicalRange | null;
	/**
	 * Sets visible logical range of data.
	 *
	 * @param range - target visible logical range of data.
	 * @example
	 * ```js
	 * chart.timeScale().setVisibleLogicalRange({ from: 0, to: Date.now() / 1000 });
	 * ```
	 */
	setVisibleLogicalRange(range: Range<number>): void;
	/**
	 * Restores default zoom level and scroll position of the time scale.
	 */
	resetTimeScale(): void;
	/**
	 * Automatically calculates the visible range to fit all data from all series.
	 */
	fitContent(): void;
	/**
	 * Converts a logical index to local x coordinate.
	 *
	 * @param logical - logical index needs to be converted
	 * @returns x coordinate of that time or `null` if the chart doesn't have data
	 */
	logicalToCoordinate(logical: Logical): Coordinate | null;
	/**
	 * Converts a coordinate to logical index.
	 *
	 * @param x - coordinate needs to be converted
	 * @returns logical index that is located on that coordinate or `null` if the chart doesn't have data
	 */
	coordinateToLogical(x: number): Logical | null;
	/**
	 * Converts a time to local x coordinate.
	 *
	 * @param time - time needs to be converted
	 * @returns x coordinate of that time or `null` if no time found on time scale
	 */
	timeToCoordinate(time: Time): Coordinate | null;
	/**
	 * Converts a coordinate to time.
	 *
	 * @param x - coordinate needs to be converted.
	 * @returns time of a bar that is located on that coordinate or `null` if there are no bars found on that coordinate.
	 */
	coordinateToTime(x: number): Time | null;
	/**
	 * Returns a width of the time scale.
	 */
	width(): number;
	/**
	 * Returns a height of the time scale.
	 */
	height(): number;
	/**
	 * Subscribe to the visible time range change events.
	 *
	 * The argument passed to the handler function is an object with `from` and `to` properties of type {@link Time}, or `null` if there is no visible data.
	 *
	 * @param handler - handler (function) to be called when the visible indexes change.
	 * @example
	 * ```js
	 * function myVisibleTimeRangeChangeHandler(newVisibleTimeRange) {
	 *     if (newVisibleTimeRange === null) {
	 *         // handle null
	 *     }
	 *
	 *     // handle new logical range
	 * }
	 *
	 * chart.timeScale().subscribeVisibleTimeRangeChange(myVisibleTimeRangeChangeHandler);
	 * ```
	 */
	subscribeVisibleTimeRangeChange(handler: TimeRangeChangeEventHandler): void;
	/**
	 * Unsubscribe a handler that was previously subscribed using {@link subscribeVisibleTimeRangeChange}.
	 *
	 * @param handler - previously subscribed handler
	 * @example
	 * ```js
	 * chart.timeScale().unsubscribeVisibleTimeRangeChange(myVisibleTimeRangeChangeHandler);
	 * ```
	 */
	unsubscribeVisibleTimeRangeChange(handler: TimeRangeChangeEventHandler): void;
	/**
	 * Subscribe to the visible logical range change events.
	 *
	 * The argument passed to the handler function is an object with `from` and `to` properties of type `number`, or `null` if there is no visible data.
	 *
	 * @param handler - handler (function) to be called when the visible indexes change.
	 * @example
	 * ```js
	 * function myVisibleLogicalRangeChangeHandler(newVisibleLogicalRange) {
	 *     if (newVisibleLogicalRange === null) {
	 *         // handle null
	 *     }
	 *
	 *     // handle new logical range
	 * }
	 *
	 * chart.timeScale().subscribeVisibleLogicalRangeChange(myVisibleLogicalRangeChangeHandler);
	 * ```
	 */
	subscribeVisibleLogicalRangeChange(handler: LogicalRangeChangeEventHandler): void;
	/**
	 * Unsubscribe a handler that was previously subscribed using {@link subscribeVisibleLogicalRangeChange}.
	 *
	 * @param handler - previously subscribed handler
	 * @example
	 * ```js
	 * chart.timeScale().unsubscribeVisibleLogicalRangeChange(myVisibleLogicalRangeChangeHandler);
	 * ```
	 */
	unsubscribeVisibleLogicalRangeChange(handler: LogicalRangeChangeEventHandler): void;
	/**
	 * Adds a subscription to time scale size changes
	 *
	 * @param handler - handler (function) to be called when the time scale size changes
	 */
	subscribeSizeChange(handler: SizeChangeEventHandler): void;
	/**
	 * Removes a subscription to time scale size changes
	 *
	 * @param handler - previously subscribed handler
	 */
	unsubscribeSizeChange(handler: SizeChangeEventHandler): void;
	/**
	 * Applies new options to the time scale.
	 *
	 * @param options - any subset of options
	 */
	applyOptions(options: DeepPartial<TimeScaleOptions>): void;
	/**
	 * Returns current options
	 *
	 * @returns currently applied options
	 */
	options(): Readonly<TimeScaleOptions>;
}
/**
 * Represents options for enabling or disabling kinetic scrolling with mouse and touch gestures.
 */
export interface KineticScrollOptions {
	/**
	 * Enable kinetic scroll with touch gestures.
	 */
	touch: boolean;
	/**
	 * Enable kinetic scroll with the mouse.
	 */
	mouse: boolean;
}
/** Represents layout options */
export interface LayoutOptions {
	/**
	 * Chart and scales background color.
	 */
	background: Background;
	/**
	 * @deprecated Use background instead.
	 */
	backgroundColor: string;
	/**
	 * Color of text on the scales.
	 */
	textColor: string;
	/**
	 * Font size of text on scales in pixels.
	 */
	fontSize: number;
	/**
	 * Font family of text on the scales.
	 */
	fontFamily: string;
}
/**
 * Represents a data point for a line or area series.
 */
export interface LineData {
	/**
	 * The time of the data.
	 */
	time: Time;
	/**
	 * Price value of the data.
	 */
	value: number;
}
/**
 * Represents style options for a line series.
 */
export interface LineStyleOptions {
	/**
	 * Line color.
	 */
	color: string;
	/**
	 * Line style.
	 */
	lineStyle: LineStyle;
	/**
	 * Line width in pixels.
	 */
	lineWidth: LineWidth;
	/**
	 * Line type.
	 */
	lineType: LineType;
	/**
	 * Show the crosshair marker.
	 */
	crosshairMarkerVisible: boolean;
	/**
	 * Crosshair marker radius in pixels.
	 */
	crosshairMarkerRadius: number;
	/**
	 * Crosshair marker border color. An empty string falls back to the the color of the series under the crosshair.
	 */
	crosshairMarkerBorderColor: string;
	/**
	 * The crosshair marker background color. An empty string falls back to the the color of the series under the crosshair.
	 */
	crosshairMarkerBackgroundColor: string;
	/**
	 * Last price animation mode.
	 */
	lastPriceAnimation: LastPriceAnimationMode;
}
/**
 * Represents options for formatting dates, times, and prices according to a locale.
 */
export interface LocalizationOptions {
	/**
	 * Current locale used to format dates. Uses the browser's language settings by default.
	 *
	 * See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl#Locale_identification_and_negotiation
	 *
	 */
	locale: string;
	/**
	 * Override formatting of the price scale crosshair label. Can be used for cases that can't be covered with built-in price formats.
	 *
	 * See also {@link PriceFormatCustom}.
	 */
	priceFormatter?: PriceFormatterFn;
	/**
	 * Override formatting of the time scale crosshair label.
	 */
	timeFormatter?: TimeFormatterFn;
	/**
	 * Date formatting string.
	 *
	 * Can contain `yyyy`, `yy`, `MMMM`, `MMM`, `MM` and `dd` literals which will be replaced with corresponding date's value.
	 *
	 * Ignored if timeFormatter has been specified.
	 */
	dateFormat: string;
}
/**
 * Represents a mouse event.
 */
export interface MouseEventParams {
	/**
	 * Time of the data at the location of the mouse event.
	 *
	 * The value will be `undefined` if the location of the event in the chart is outside the range of available data.
	 */
	time?: UTCTimestamp | BusinessDay;
	/**
	 * Location of the event in the chart.
	 *
	 * The value will be `undefined` if the event is fired outside the chart, for example a mouse leave event.
	 */
	point?: Point;
	/**
	 * Prices of all series at the location of the event in the chart.
	 *
	 * Keys of the map are {@link ISeriesApi} instances. Values are prices.
	 * Each price is a number for line, area, and histogram series or a OHLC object for candlestick and bar series.
	 */
	seriesPrices: Map<ISeriesApi<SeriesType>, BarPrice | BarPrices>;
	/**
	 * The {@link ISeriesApi} for the series at the point of the mouse event.
	 */
	hoveredSeries?: ISeriesApi<SeriesType>;
	/**
	 * The ID of the marker at the point of the mouse event.
	 */
	hoveredMarkerId?: SeriesMarker<Time>["id"];
}
/**
 * Represents a point on the chart.
 */
export interface Point {
	/**
	 * The x coordinate.
	 */
	readonly x: Coordinate;
	/**
	 * The y coordinate.
	 */
	readonly y: Coordinate;
}
/**
 * Represents series value formatting options.
 * The precision and minMove properties allow wide customization of formatting.
 *
 * @example
 * minMove = 0.01 , precision is not specified. Prices will change like 1.13, 1.14, 1.15 etc.
 * minMove = 0.01 , precision = 3. Prices will change like 1.130, 1.140, 1.150 etc.
 * minMove = 0.05 , precision is not specified. Prices will change like 1.10, 1.15, 1.20
 */
export interface PriceFormatBuiltIn {
	/**
	 * Built-in price formats.
	 * 'price' is the most common choice; it allows customization of precision and rounding of prices.
	 * 'volume' uses abbreviation for formatting prices like '1.2K' or '12.67M'.
	 * 'percent' uses '%' sign at the end of prices.
	 */
	type: "price" | "volume" | "percent";
	/**
	 * Number of digits after the decimal point.
	 * If it is not set, then its value is calculated automatically based on minMove.
	 */
	precision: number;
	/**
	 * Minimal step of the price. This value shouldn't have more decimal digits than the precision.
	 */
	minMove: number;
}
/**
 * Represents series value formatting options.
 */
export interface PriceFormatCustom {
	/**
	 * The custom price format.
	 */
	type: "custom";
	/**
	 * Override price formatting behaviour. Can be used for cases that can't be covered with built-in price formats.
	 */
	formatter: PriceFormatterFn;
	/**
	 * Minimal step of the price.
	 */
	minMove: number;
}
/**
 * Represents a price line.
 */
export interface PriceLineOptions {
	/**
	 * Price line's value.
	 */
	price: number;
	/**
	 * Price line's color.
	 */
	color: string;
	/**
	 * Price line's width in pixels.
	 */
	lineWidth: LineWidth;
	/**
	 * Price line's style.
	 */
	lineStyle: LineStyle;
	/**
	 * Display the current price value in on the price scale.
	 */
	axisLabelVisible: boolean;
	/**
	 * Price line's on the chart pane.
	 */
	title: string;
}
/**
 * Represents a price range.
 */
export interface PriceRange {
	/**
	 * Maximum value in the range.
	 */
	minValue: number;
	/**
	 * Minimum value in the range.
	 */
	maxValue: number;
}
/** Defines margins of the price scale. */
export interface PriceScaleMargins {
	/** Top margin in percentages. Must be greater or equal to 0 and less than 100. */
	top: number;
	/** Bottom margin in percentages. Must be greater or equal to 0 and less than 100. */
	bottom: number;
}
/** Structure that describes price scale options */
export interface PriceScaleOptions {
	/**
	 * Automatically set price range based on visible data range.
	 */
	autoScale: boolean;
	/** Price scale mode. */
	mode: PriceScaleMode;
	/**
	 * Invert the price scale, so that a upwards trend is shown as a downwards trend and vice versa.
	 * Affects both the price scale and the data on the chart.
	 */
	invertScale: boolean;
	/**
	 * Align price scale labels to prevent them from overlapping.
	 */
	alignLabels: boolean;
	/**
	 * Price scale margins.
	 */
	scaleMargins: PriceScaleMargins;
	/**
	 * Set true to draw a border between the price scale and the chart area.
	 */
	borderVisible: boolean;
	/**
	 * Price scale border color.
	 */
	borderColor: string;
	/**
	 * Show top and bottom corner labels only if entire text is visible.
	 */
	entireTextOnly: boolean;
	/** Indicates if this price scale visible. Ignored by overlay price scales. */
	visible: boolean;
	/** Draw small horizontal line on price axis labels. */
	drawTicks: boolean;
}
/**
 * Represents a generic range `from` one value `to` another.
 */
export interface Range<T> {
	/**
	 * The from value. The start of the range.
	 */
	from: T;
	/**
	 * The to value. The end of the range.
	 */
	to: T;
}
/**
 * Represents the type of data that a series contains.
 *
 * For example a bar series contains {@link BarData} or {@link WhitespaceData}.
 */
export interface SeriesDataItemTypeMap {
	/**
	 * The types of bar series data.
	 */
	Bar: BarData | WhitespaceData;
	/**
	 * The types of candlestick series data.
	 */
	Candlestick: BarData | WhitespaceData;
	/**
	 * The types of area series data.
	 */
	Area: LineData | WhitespaceData;
	/**
	 * The types of baseline series data.
	 */
	Baseline: LineData | WhitespaceData;
	/**
	 * The types of line series data.
	 */
	Line: LineData | WhitespaceData;
	/**
	 * The types of histogram series data.
	 */
	Histogram: HistogramData | WhitespaceData;
}
/**
 * Represents a series marker.
 */
export interface SeriesMarker<TimeType> {
	/**
	 * The time of the marker.
	 */
	time: TimeType;
	/**
	 * The position of the marker.
	 */
	position: SeriesMarkerPosition;
	/**
	 * The shape of the marker.
	 */
	shape: SeriesMarkerShape;
	/**
	 * The color of the marker.
	 */
	color: string;
	/**
	 * The ID of the marker.
	 */
	id?: string;
	/**
	 * The optional text of the marker.
	 */
	text?: string;
	/**
	 * The optional size of the marker.
	 */
	size?: number;
}
/**
 * Represents options common for all types of series
 */
export interface SeriesOptionsCommon {
	/**
	 * Visibility of the label with the latest visible price on the price scale.
	 */
	lastValueVisible: boolean;
	/** Title of the series. This label is placed with price axis label */
	title: string;
	/** Target price scale to bind new series to */
	priceScaleId?: string;
	/** Show the series. */
	visible: boolean;
	/**
	 * Show the price line. Price line is a horizontal line indicating the last price of the series.
	 */
	priceLineVisible: boolean;
	/**
	 * The source to use for the value of the price line.
	 */
	priceLineSource: PriceLineSource;
	/**
	 * Width of the price line.
	 */
	priceLineWidth: LineWidth;
	/**
	 * Color of the price line.
	 */
	priceLineColor: string;
	/**
	 * Price line style.
	 */
	priceLineStyle: LineStyle;
	/** Price format. */
	priceFormat: PriceFormat;
	/**
	 * Visibility of base line. Suitable for percentage and `IndexedTo100` scales.
	 */
	baseLineVisible: boolean;
	/**
	 * Color of the base line in `IndexedTo100` mode.
	 */
	baseLineColor: string;
	/**
	 * Base line width. Suitable for percentage and `IndexedTo10` scales.
	 */
	baseLineWidth: LineWidth;
	/**
	 * Base line style. Suitable for percentage and indexedTo100 scales.
	 */
	baseLineStyle: LineStyle;
	/** Override the default {@link AutoscaleInfo} provider. */
	autoscaleInfoProvider?: AutoscaleInfoProvider;
	/** @deprecated Use priceScale method of the series to apply options instead. */
	scaleMargins?: PriceScaleMargins;
}
/**
 * Represents the type of options for each series type.
 *
 * For example a bar series has options represented by {@link BarSeriesOptions}.
 */
export interface SeriesOptionsMap {
	/**
	 * The type of bar series options.
	 */
	Bar: BarSeriesOptions;
	/**
	 * The type of candlestick series options.
	 */
	Candlestick: CandlestickSeriesOptions;
	/**
	 * The type of area series options.
	 */
	Area: AreaSeriesOptions;
	/**
	 * The type of baseline series options.
	 */
	Baseline: BaselineSeriesOptions;
	/**
	 * The type of line series options.
	 */
	Line: LineSeriesOptions;
	/**
	 * The type of histogram series options.
	 */
	Histogram: HistogramSeriesOptions;
}
/**
 * Represents the type of partial options for each series type.
 *
 * For example a bar series has options represented by {@link BarSeriesPartialOptions}.
 */
export interface SeriesPartialOptionsMap {
	/**
	 * The type of bar series partial options.
	 */
	Bar: BarSeriesPartialOptions;
	/**
	 * The type of candlestick series partial options.
	 */
	Candlestick: CandlestickSeriesPartialOptions;
	/**
	 * The type of area series partial options.
	 */
	Area: AreaSeriesPartialOptions;
	/**
	 * The type of baseline series partial options.
	 */
	Baseline: BaselineSeriesPartialOptions;
	/**
	 * The type of line series partial options.
	 */
	Line: LineSeriesPartialOptions;
	/**
	 * The type of histogram series partial options.
	 */
	Histogram: HistogramSeriesPartialOptions;
}
/**
 * Represents a solid color.
 */
export interface SolidColor {
	/**
	 * Type of color.
	 */
	type: ColorType.Solid;
	/** Color */
	color: string;
}
/**
 * Options for the time scale; the horizontal scale at the bottom of the chart that displays the time of data.
 */
export interface TimeScaleOptions {
	/**
	 * The margin space in bars from the right side of the chart.
	 */
	rightOffset: number;
	/**
	 * The space between bars in pixels.
	 */
	barSpacing: number;
	/**
	 * The minimum space between bars in pixels.
	 */
	minBarSpacing: number;
	/**
	 * Prevent scrolling to the left of the first bar.
	 */
	fixLeftEdge: boolean;
	/**
	 * Prevent scrolling to the right of the most recent bar.
	 */
	fixRightEdge: boolean;
	/**
	 * Prevent changing the visible time range during chart resizing.
	 */
	lockVisibleTimeRangeOnResize: boolean;
	/**
	 * Prevent the hovered bar from moving when scrolling.
	 */
	rightBarStaysOnScroll: boolean;
	/**
	 * Show the time scale border.
	 */
	borderVisible: boolean;
	/**
	 * The time scale border color.
	 */
	borderColor: string;
	/**
	 * Show the time scale.
	 */
	visible: boolean;
	/**
	 * Show the time, not just the date, in the time scale and vertical crosshair label.
	 */
	timeVisible: boolean;
	/**
	 * Show seconds in the time scale and vertical crosshair label in `hh:mm:ss` format for intraday data.
	 */
	secondsVisible: boolean;
	/**
	 * Shift the visible range to the right (into the future) by the number of new bars when new data is added.
	 *
	 * Note that this only applies when the last bar is visible.
	 */
	shiftVisibleRangeOnNewBar: boolean;
	/**
	 * Override the default tick marks formatter.
	 */
	tickMarkFormatter?: TickMarkFormatter;
}
/**
 * Represents a vertical gradient of two colors.
 */
export interface VerticalGradientColor {
	/**
	 * Type of color.
	 */
	type: ColorType.VerticalGradient;
	/** Top color */
	topColor: string;
	/** Bottom color */
	bottomColor: string;
}
/** Watermark options. */
export interface WatermarkOptions {
	/**
	 * Watermark color.
	 */
	color: string;
	/**
	 * Display the watermark.
	 */
	visible: boolean;
	/**
	 * Text of the watermark. Word wrapping is not supported.
	 */
	text: string;
	/**
	 * Font size in pixels.
	 */
	fontSize: number;
	/**
	 * Font family.
	 */
	fontFamily: string;
	/**
	 * Font style.
	 */
	fontStyle: string;
	/**
	 * Horizontal alignment inside the chart area.
	 */
	horzAlign: HorzAlign;
	/**
	 * Vertical alignment inside the chart area.
	 */
	vertAlign: VertAlign;
}
/**
 * Represents a whitespace data item, which is a data point without a value.
 */
export interface WhitespaceData {
	/**
	 * The time of the data.
	 */
	time: Time;
}

export {
	LastPriceAnimationMode as LasPriceAnimationMode,
};

export {};
